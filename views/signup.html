<!DOCTYPE html>
<html>
<head>  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />  <title>Theatre Shifts</title>
    <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Theatre Shifts">
  <link rel="apple-touch-icon" href="/icons/ios/180.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/ios/152.png">
  <link rel="apple-touch-icon" sizes="167x167" href="/icons/ios/167.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/ios/180.png">
  <meta name="theme-color" content="#007bff">
  <meta name="msapplication-TileColor" content="#007bff">
  <meta name="msapplication-TileImage" content="/icons/windows11/Square150x150Logo.scale-200.png">
  
  <style>    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      max-width: 1000px; 
      margin: 0 auto; 
      padding: 2rem; 
      background-color: #f8f9fa;
      padding-bottom: 6rem; /* Extra space for potential iOS banner */
    }
    
    @media (max-width: 768px) {
      body {
        padding: 1rem;
        padding-bottom: 6rem;
      }
    }
    .container {
      background: white;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 { 
      color: #333; 
      margin-bottom: 1rem;
      text-align: center;
    }
    h2 {
      color: #333;
      margin-top: 2rem;
      margin-bottom: 1rem;
      border-bottom: 2px solid #007bff;
      padding-bottom: 0.5rem;
    }
    .welcome-text {
      text-align: center;
      color: #666;
      margin-bottom: 2rem;
      font-size: 1.1rem;
    }
    .header-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
    }    .pdf-button {
      background: #6f42c1;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.2s;
    }
    .pdf-button:hover {
      background: #5a32a3;
    }
    
    .logout-button {
      background: #dc3545;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.2s;
      margin-left: 0.5rem;
    }
    .logout-button:hover {
      background: #c82333;
    }      /* Mobile floating PDF and logout buttons */
    @media (max-width: 768px) {
      .header-actions {
        justify-content: center;
      }
      
      .pdf-button {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 1001;
        border-radius: 50%;
        width: 3rem;
        height: 3rem;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      }
      
      .logout-button {
        position: fixed;
        top: 1rem;
        left: 1rem;
        z-index: 1001;
        border-radius: 50%;
        width: 3rem;
        height: 3rem;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        margin-left: 0;
      }
      
      .pdf-button:hover, .logout-button:hover {
        transform: scale(1.05);
      }
      
      .pdf-button-text, .logout-button-text {
        display: none;
      }
      
      .pdf-button-icon, .logout-button-icon {
        display: inline;
      }
    }
    
    @media (min-width: 769px) {
      .pdf-button-text, .logout-button-text {
        display: inline;
      }
      
      .pdf-button-icon, .logout-button-icon {
        display: none;
      }
    }
      /* iOS PWA Install Banner */
    .ios-install-banner {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #fff;
      border-top: 1px solid #ccc;
      padding: 1rem;
      text-align: center;
      font-family: inherit;
      z-index: 1000;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
    }
    
    .ios-install-banner .close-btn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      margin-left: 0.5rem;
      cursor: pointer;
      font-size: 0.8rem;
    }
    
    .ios-install-banner .close-btn:hover {
      background: #c82333;
    }
      /* Calendar Styles */
    .calendar-section {
      margin: 2rem 0;
    }    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    @media (max-width: 768px) {
      .calendar-header {
        flex-direction: column;
        align-items: stretch;
        text-align: center;
      }
      
      .calendar-header h2 {
        margin: 0 0 1rem 0;
        border-bottom: none;
        padding-bottom: 0;
      }
    }    .calendar-nav {
      display: flex;
      gap: 1rem;
      align-items: center;
      justify-content: center;
    }
    
    @media (max-width: 768px) {
      .calendar-nav {
        width: 100%;
        justify-content: space-between;
      }
      
      .calendar-nav button {
        flex: 1;
        max-width: 120px;
      }
      
      .calendar-nav span {
        flex: 2;
        text-align: center;
        font-weight: bold;
        color: #333;
      }
    }
    .calendar-nav button {
      background: #007bff;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
      transition: background-color 0.2s;
    }
    .calendar-nav button:hover {
      background: #0056b3;
    }    .calendar {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 1px;
      background: #ddd;
      border: 1px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 1rem;
    }
    
    @media (max-width: 768px) {
      .calendar {
        font-size: 0.8rem;
        min-width: 100%;
        width: 100%;
        grid-template-columns: repeat(7, minmax(0, 1fr));
      }
    }
    .calendar-day-header {
      background: #007bff;
      color: white;
      padding-top: 0.75rem;
      padding-bottom: 0.75rem;
      text-align: center;
      font-weight: bold;
      font-size: 0.9rem;
    }    .calendar-day {
      background: white;
      padding: 0.5rem;
      min-height: 70px;
      position: relative;
      border: 1px solid #eee;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    @media (max-width: 768px) {
      .calendar-day {
        padding: 0.25rem;
        min-height: 50px;
      }
    }
    .calendar-day:hover {
      background: #f8f9fa;
    }
    .calendar-day.other-month {
      background: #f8f9fa;
      color: #999;
    }
    .calendar-day.today {
      background: #fff3cd;
      border-color: #ffc107;
      font-weight: bold;
    }
    .calendar-day-number {
      font-weight: bold;
      margin-bottom: 0.25rem;
      font-size: 0.9rem;
    }    .shift-indicators {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      gap: 1px;
    }
    
    @media (max-width: 768px) {
      .shift-indicators {
        top: 75%;
        transform: translate(-50%, -75%);
      }
    }    .shift-icon {
      width: 20px;
      height: 20px;
      border-radius: 0; /* Square for assigned shifts */
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      color: white;
      line-height: 1;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    .shift-icon.available {
      border-radius: 50%; /* Make available shifts circular */
    }
    .shift-icon.assigned {
      background: #28a745; /* Green for assigned shifts */
    }
    .shift-icon.available {
      background: #6f42c1; /* Purple - colorblind safe alternative to orange */
    }
    .calendar-legend {
      display: flex;
      gap: 2rem;
      justify-content: center;
      margin-top: 1rem;
      font-size: 0.9rem;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }    .legend-dot {
      width: 20px;
      height: 20px;
      border-radius: 0; /* Square for assigned shifts */
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      color: white;
      line-height: 1;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    .legend-dot.available {
      border-radius: 50%; /* Make available shifts legend circular */
    }
    .legend-dot.assigned {
      background: #28a745;
    }
    .legend-dot.available {
      background: #6f42c1;
    }
    
    .shifts-section {
      margin: 2rem 0;
    }
    .shift { 
      margin-bottom: 1rem; 
      padding: 1rem;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      background: #fafafa;
      transition: background-color 0.2s;
    }
    .shift:hover {
      background: #f0f0f0;
    }
    .assigned-shift {
      background: #d4edda;
      border-color: #c3e6cb;
    }
    .assigned-shift:hover {
      background: #c3e6cb;
    }
    .shift input[type="checkbox"] {
      margin-right: 0.75rem;
      transform: scale(1.2);
    }
    .shift-info {
      display: flex;
      flex-direction: column;
      margin-left: 1.5rem;
    }
    .shift-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .shift-details {
      flex-grow: 1;
    }
    .shift-role {
      font-weight: bold;
      color: #007bff;
      margin-bottom: 0.25rem;
    }
    .shift-time {
      color: #666;
      font-size: 0.95rem;
    }
    .show-name {
      font-weight: 500;
      color: #495057;
      margin-bottom: 0.25rem;
    }
    .shift-date {
      font-weight: 500;
      color: #495057;
      margin-bottom: 0.25rem;
    }
    .no-shifts {
      text-align: center;
      color: #666;
      padding: 2rem;
      background: #f8f9fa;
      border-radius: 6px;
      margin: 1rem 0;
    }
    .form-actions {
      margin-top: 2rem;
      text-align: center;
    }
    button, .btn { 
      padding: 0.75rem 2rem; 
      background: #28a745;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      transition: background-color 0.2s;
      margin: 0.25rem;
    }
    button:hover, .btn:hover {
      background: #218838;
    }
    button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }
    .btn-danger {
      background: #dc3545;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
    }
    .btn-danger:hover {
      background: #c82333;
    }
    .success-message {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
      padding: 1rem;
      border-radius: 6px;
      margin-top: 1rem;
      text-align: center;
      display: none;
    }
    .error-message {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
      padding: 1rem;
      border-radius: 6px;
      margin-top: 1rem;
      text-align: center;
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">    <div class="header-actions">
      <h1>Theatre Shifts</h1>
      <div>
        <button class="logout-button" onclick="logout()">
          <span class="logout-button-text">🚪 Logout</span>
          <span class="logout-button-icon">🚪</span>
        </button>
        <button class="pdf-button" onclick="downloadPDF()">
          <span class="pdf-button-text">📄 Download PDF</span>
          <span class="pdf-button-icon">📄</span>
        </button>
      </div>
    </div><div class="welcome-text">
      Hello, <strong>{{name}}</strong>! Manage your shifts below.
    </div>
      <!-- Calendar Section -->
    <div class="calendar-section">
      <div class="calendar-header">
        <h2>Shift Calendar</h2>
        <div class="calendar-nav">
          <button onclick="changeMonth(-1)">Previous</button>
          <span id="currentMonth"></span>
          <button onclick="changeMonth(1)">Next</button>
        </div>
      </div>
      <div id="calendar"></div>      <div class="calendar-legend">
        <div class="legend-item">
          <div class="legend-dot assigned"></div>
          <span>Your Shifts</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot available"></div>
          <span>Available shifts</span>
        </div>
      </div>
    </div>
    
    <!-- Assigned Shifts Section -->
    <div class="shifts-section">
      <h2>Your Assigned Shifts</h2>
      <div id="assignedShifts"></div>
    </div>
    
    <!-- Available Shifts Section -->
    <form id="signupForm">
      <div class="shifts-section">
        <h2>Available Shifts</h2>
        <div id="availableShifts"></div>
      </div>
      
      <div class="form-actions">
        <button type="submit" id="submitBtn">Sign Up for Selected Shifts</button>
      </div>
    </form>
    
    <div id="successMessage" class="success-message">
      <strong>Success!</strong> Your shift assignments have been updated.
    </div>
    
    <div id="errorMessage" class="error-message">
      <strong>Oops!</strong> There was an error processing your request. Please try again.
    </div>
  </div>

  <!-- Template data -->
  <script type="application/json" id="assignedShiftsData">{{{assignedShiftsJson}}}</script>
  <script type="application/json" id="availableShiftsData">{{{shiftsJson}}}</script>
  <script type="application/json" id="volunteerData">{"id": "{{volunteerId}}"}</script>  <script src="/src/utils/modal.js"></script>
  <script src="/src/utils/timezone-client.js"></script>
  <script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js" onload="console.log('jsPDF loaded successfully')" onerror="loadJsPDFFallback()"></script>
  
  <script>
    function loadJsPDFFallback() {
      console.warn('Primary jsPDF CDN failed, trying fallback...');
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.2/jspdf.umd.min.js';
      script.onload = () => console.log('jsPDF fallback loaded successfully');
      script.onerror = () => {
        console.error('Both jsPDF CDNs failed to load');
        // Try one more fallback
        const script2 = document.createElement('script');
        script2.src = 'https://cdn.jsdelivr.net/npm/jspdf@2.5.2/dist/jspdf.umd.min.js';
        script2.onload = () => console.log('jsPDF third fallback loaded successfully');
        script2.onerror = () => console.error('All jsPDF CDNs failed to load');
        document.head.appendChild(script2);
      };
      document.head.appendChild(script);
    }
  </script>
  
  <!-- PWA Service Worker Registration -->
  <script>
    // Save volunteer info to localStorage when they visit their signup page
    (function() {
      const volunteer = JSON.parse(document.getElementById('volunteerData').textContent);
      const volunteerName = document.querySelector('.welcome-text strong').textContent;
      
      // Save current volunteer to localStorage
      const savedVolunteers = JSON.parse(localStorage.getItem('savedVolunteers') || '[]');
      
      // Check if this volunteer is already saved
      const existingIndex = savedVolunteers.findIndex(v => v.id === volunteer.id);
      
      const volunteerData = {
        id: volunteer.id,
        name: volunteerName,
        lastVisited: new Date().toISOString()
      };
      
      if (existingIndex >= 0) {
        // Update existing volunteer's last visited time
        savedVolunteers[existingIndex] = volunteerData;
      } else {
        // Add new volunteer
        savedVolunteers.push(volunteerData);
      }
      
      // Keep only the 10 most recent volunteers
      savedVolunteers.sort((a, b) => new Date(b.lastVisited) - new Date(a.lastVisited));
      if (savedVolunteers.length > 10) {
        savedVolunteers.splice(10);
      }
      
      localStorage.setItem('savedVolunteers', JSON.stringify(savedVolunteers));
    })();

    // Register Service Worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/service-worker.js')
        .then(() => console.log('SW registered'))
        .catch(err => console.error('SW registration failed:', err));
    }

    // iOS PWA Install Banner
    function isIos() {
      return /iphone|ipad|ipod/.test(window.navigator.userAgent.toLowerCase());
    }

    function isInStandaloneMode() {
      return window.navigator.standalone === true;
    }

    function showIOSInstallBanner() {
      if (isIos() && !isInStandaloneMode()) {
        // Check if banner was previously dismissed
        if (localStorage.getItem('ios-install-banner-dismissed') === 'true') {
          return;
        }

        const banner = document.createElement('div');
        banner.className = 'ios-install-banner';
        banner.innerHTML = `
          📲 To install this app, tap <strong>Share</strong> then <strong>Add to Home Screen</strong>
          <button class="close-btn" onclick="dismissIOSBanner(this)">✖️</button>
        `;
        document.body.appendChild(banner);
      }
    }    function dismissIOSBanner(button) {
      button.parentNode.remove();
      localStorage.setItem('ios-install-banner-dismissed', 'true');
    }

    // Make dismissIOSBanner globally accessible
    window.dismissIOSBanner = dismissIOSBanner;

    // Android Install Prompt
    let deferredPrompt;

    window.addEventListener('beforeinstallprompt', e => {
      e.preventDefault();
      deferredPrompt = e;
      
      // You could show a custom install button here if desired
      console.log('Install prompt available');
    });

    // Show iOS banner after page loads
    window.addEventListener('load', () => {
      setTimeout(showIOSInstallBanner, 2000); // Delay to avoid interfering with page load
    });
  </script>
  
  <script>// Load data from the template
    const assignedShiftsElement = document.getElementById('assignedShiftsData');
    const availableShiftsElement = document.getElementById('availableShiftsData');
    const volunteerElement = document.getElementById('volunteerData');
      const assignedShifts = JSON.parse(assignedShiftsElement.textContent);
    const availableShifts = JSON.parse(availableShiftsElement.textContent);
    const volunteer = JSON.parse(volunteerElement.textContent);
      // Debug: Log the raw data to understand its structure
    console.log('Raw assignedShifts data:', assignedShifts);
    console.log('Raw availableShifts data:', availableShifts);
    
    // Debug: Check the structure more deeply
    if (assignedShifts && assignedShifts.length > 0) {
      console.log('First assigned shift structure:', assignedShifts[0]);
    }
    if (availableShifts && availableShifts.length > 0) {
      console.log('First available shift structure:', availableShifts[0]);
    }
    
    const assignedContainer = document.getElementById('assignedShifts');
    const availableContainer = document.getElementById('availableShifts');
    const submitBtn = document.getElementById('submitBtn');
    
    // Calendar state - initialize in Adelaide timezone
    let currentCalendarDate = AdelaideTime.getNowAdelaide();
      function formatShiftTime(arriveTime, departTime) {
      return AdelaideTime.formatShiftTimeAdelaide(arriveTime, departTime);
    }    function generateCalendar() {
      const calendar = document.getElementById('calendar');
      const monthSpan = document.getElementById('currentMonth');
      const now = AdelaideTime.getNowAdelaide();
      const currentMonth = currentCalendarDate.getMonth();
      const currentYear = currentCalendarDate.getFullYear();
      
      // Set month header
      if (monthSpan) {
        monthSpan.textContent = AdelaideTime.getMonthYearAdelaide(currentCalendarDate);
      }
        // Create calendar grid
      const firstDay = new Date(currentYear, currentMonth, 1);
      const lastDay = new Date(currentYear, currentMonth + 1, 0);
        // Get first day of calendar (start from Monday of the week containing the 1st)
      const startDate = new Date(firstDay);
      const dayOfWeek = firstDay.getDay(); // 0 = Sunday, 1 = Monday, etc.
      const mondayOffset = dayOfWeek === 0 ? -6 : -(dayOfWeek - 1); // If Sunday, go back 6 days, otherwise go back (dayOfWeek - 1) days
      startDate.setDate(startDate.getDate() + mondayOffset);
      
      // Get last day of calendar (end on Sunday of the week containing the last day)
      const endDate = new Date(lastDay);
      const lastDayOfWeek = lastDay.getDay();
      const sundayOffset = lastDayOfWeek === 0 ? 0 : (7 - lastDayOfWeek); // If Sunday, no offset, otherwise add days to reach Sunday
      endDate.setDate(endDate.getDate() + sundayOffset);
      
      // Clear calendar
      calendar.innerHTML = '';
      calendar.className = 'calendar';
      
      // Create day headers (Monday to Sunday)
      const dayHeaders = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
      dayHeaders.forEach(day => {
        const header = document.createElement('div');
        header.className = 'calendar-day-header';
        header.textContent = day;
        calendar.appendChild(header);
      });// Create shift lookup maps for efficient searching
      const assignedShiftDates = new Set();
      const availableShiftDates = new Set();      // Helper function to safely convert date to YYYY-MM-DD format in Adelaide timezone
      function dateToString(dateValue) {
        return AdelaideTime.dateToStringAdelaide(dateValue);
      }      // Build assigned shift dates - handle multiple possible data structures
      if (assignedShifts && Array.isArray(assignedShifts)) {
        const now = AdelaideTime.getNowAdelaide();
        assignedShifts.forEach((show, index) => {
          console.log(`Processing assigned show ${index}:`, show);
          
          // Handle case where shifts are directly in the show object (flattened structure)
          if (show.show_date && show.depart_time) {
            const shiftEndTime = new Date(show.depart_time);
            if (shiftEndTime > now) {
              const dateOnly = dateToString(show.show_date);
              if (dateOnly) {
                assignedShiftDates.add(dateOnly);
                console.log(`Added assigned date from flattened: ${show.show_date} -> ${dateOnly}`);
              }
            }
          }
          // Handle legacy flattened structure with 'date' field
          else if (show.date && show.depart_time) {
            const shiftEndTime = new Date(show.depart_time);
            if (shiftEndTime > now) {
              const dateOnly = dateToString(show.date);
              if (dateOnly) {
                assignedShiftDates.add(dateOnly);
                console.log(`Added assigned date from legacy flattened: ${show.date} -> ${dateOnly}`);
              }
            }
          }
          // Handle case where shifts are nested in performances
          else if (show.performances && Array.isArray(show.performances)) {
            show.performances.forEach((perf, perfIndex) => {
              console.log(`Processing assigned performance ${perfIndex}:`, perf);
              if (perf.date && perf.shifts) {
                perf.shifts.forEach(shift => {
                  const shiftEndTime = new Date(shift.depart_time);
                  if (shiftEndTime > now) {
                    const dateOnly = dateToString(perf.date);
                    if (dateOnly) {
                      assignedShiftDates.add(dateOnly);
                      console.log(`Added assigned date from performance: ${perf.date} -> ${dateOnly}`);
                    }
                  }
                });
              }
            });
          }
        });
      }      // Build available shift dates (only for performances where user doesn't have assigned shifts)
      if (availableShifts && Array.isArray(availableShifts)) {
        const now = AdelaideTime.getNowAdelaide();
        availableShifts.forEach((show, index) => {
          console.log(`Processing available show ${index}:`, show);
          
          // Handle case where shifts are directly in the show object (flattened structure)
          if (show.show_date && show.depart_time) {
            const shiftEndTime = new Date(show.depart_time);
            if (shiftEndTime > now) {
              const dateOnly = dateToString(show.show_date);
              if (dateOnly && !assignedShiftDates.has(dateOnly)) {
                availableShiftDates.add(dateOnly);
                console.log(`Added available date from flattened: ${show.show_date} -> ${dateOnly}`);
              }
            }
          }
          // Handle legacy flattened structure with 'date' field
          else if (show.date && show.depart_time) {
            const shiftEndTime = new Date(show.depart_time);
            if (shiftEndTime > now) {
              const dateOnly = dateToString(show.date);
              if (dateOnly && !assignedShiftDates.has(dateOnly)) {
                availableShiftDates.add(dateOnly);
                console.log(`Added available date from legacy flattened: ${show.date} -> ${dateOnly}`);
              }
            }
          }
          // Handle case where shifts are nested in performances
          else if (show.performances && Array.isArray(show.performances)) {
            show.performances.forEach((perf, perfIndex) => {
              console.log(`Processing available performance ${perfIndex}:`, perf);
              if (perf.date && perf.shifts) {
                const hasFutureShifts = perf.shifts.some(shift => {
                  const shiftEndTime = new Date(shift.depart_time);
                  return shiftEndTime > now;
                });
                
                if (hasFutureShifts) {
                  const dateOnly = dateToString(perf.date);
                  if (dateOnly && !assignedShiftDates.has(dateOnly)) {
                    availableShiftDates.add(dateOnly);
                    console.log(`Added available date from performance: ${perf.date} -> ${dateOnly}`);
                  }
                }
              }
            });
          }
        });
      }
      
      // Debug: Log the final sets of dates
      console.log('Calendar: Assigned shift dates:', Array.from(assignedShiftDates));
      console.log('Calendar: Available shift dates:', Array.from(availableShiftDates));
      
      // Generate calendar days
      const currentDate = new Date(startDate);
      while (currentDate <= endDate) {
        const dayDiv = document.createElement('div');
        dayDiv.className = 'calendar-day';
          const isCurrentMonth = currentDate.getMonth() === currentMonth;
        const isToday = AdelaideTime.isTodayAdelaide(currentDate);
        
        // Create Adelaide timezone date string for comparison
        // Important: Create the date as if it's in Adelaide timezone to match shift data
        const year = currentDate.getFullYear();
        const month = String(currentDate.getMonth() + 1).padStart(2, '0');
        const day = String(currentDate.getDate()).padStart(2, '0');
        const dateStr = `${year}-${month}-${day}`;
        
        // Debug: Log calendar date creation
        if (dateStr === '2025-06-22' || dateStr === '2025-06-28') {
          console.log(`Calendar: Creating day ${dateStr} from local date:`, currentDate.toISOString());
        }
        
        // Apply styling classes
        if (!isCurrentMonth) {
          dayDiv.classList.add('other-month');
        }
        if (isToday) {
          dayDiv.classList.add('today');
        }
        
        // Add day number
        const dayNumber = document.createElement('div');
        dayNumber.className = 'calendar-day-number';
        dayNumber.textContent = currentDate.getDate();
        dayDiv.appendChild(dayNumber);        // Add shift indicators
        const hasAssignedShift = assignedShiftDates.has(dateStr);
        const hasAvailableShift = availableShiftDates.has(dateStr);
        
        // Debug: Log some key dates to help troubleshoot
        if (dateStr === '2025-06-22' || dateStr === '2025-06-28') {
          console.log(`Date ${dateStr}: assigned=${hasAssignedShift}, available=${hasAvailableShift}`);
        }
        
        if (hasAssignedShift || hasAvailableShift) {
          const indicatorsContainer = document.createElement('div');
          indicatorsContainer.className = 'shift-indicators';
            if (hasAssignedShift) {
            const assignedIcon = document.createElement('div');
            assignedIcon.className = 'shift-icon assigned';
            assignedIcon.title = 'You have assigned shifts on this day';
            indicatorsContainer.appendChild(assignedIcon);
          }
          
          if (hasAvailableShift) {
            const availableIcon = document.createElement('div');
            availableIcon.className = 'shift-icon available';
            availableIcon.title = 'Available shifts on this day';
            indicatorsContainer.appendChild(availableIcon);
          }
          
          dayDiv.appendChild(indicatorsContainer);
        }
        
        calendar.appendChild(dayDiv);
        currentDate.setDate(currentDate.getDate() + 1);
      }
    }

    function changeMonth(delta) {
      // Update calendar date maintaining Adelaide timezone alignment
      const newMonth = currentCalendarDate.getMonth() + delta;
      const newYear = currentCalendarDate.getFullYear() + Math.floor(newMonth / 12);
      const adjustedMonth = ((newMonth % 12) + 12) % 12;
      
      currentCalendarDate = new Date(newYear, adjustedMonth, 1);
      generateCalendar();
    }    function populateAssignedShifts() {
      if (assignedShifts.length === 0) {
        assignedContainer.innerHTML = '<div class="no-shifts">You are not currently assigned to any shifts.</div>';
      } else {
        const now = AdelaideTime.getNowAdelaide();
        
        // Flatten all shifts and sort by date
        const allShifts = [];
        assignedShifts.forEach(show => {
          // Handle flattened structure (shifts directly in show)
          if (show.show_date && show.arrive_time) {
            const shiftEndTime = new Date(show.depart_time);
            if (shiftEndTime > now) {
              allShifts.push({
                id: show.id,
                role: show.role,
                arrive_time: show.arrive_time,
                depart_time: show.depart_time,
                show_name: show.show_name,
                date: show.show_date,
                start_time: show.start_time,
                end_time: show.end_time
              });
            }
          }
          // Handle nested structure (performances with shifts)
          else if (show.performances && Array.isArray(show.performances)) {
            show.performances.forEach(performance => {
              if (performance.shifts && Array.isArray(performance.shifts)) {
                performance.shifts.forEach(shift => {
                  // Check if shift end time has passed
                  const shiftEndTime = new Date(shift.depart_time);
                  if (shiftEndTime > now) {
                    allShifts.push({
                      ...shift,
                      show_name: show.show_name,
                      date: performance.date,
                      start_time: performance.start_time,
                      end_time: performance.end_time
                    });
                  }
                });
              }
            });
          }
        });
        
        // Sort by date, then by arrive time
        allShifts.sort((a, b) => {
          const dateCompare = new Date(a.date) - new Date(b.date);
          if (dateCompare !== 0) return dateCompare;
          return new Date(a.arrive_time) - new Date(b.arrive_time);
        });
        if (allShifts.length === 0) {
          assignedContainer.innerHTML = '<div class="no-shifts">You are not currently assigned to any upcoming shifts.</div>';
        } else {
          assignedContainer.innerHTML = allShifts.map(shift => `            <div class="shift assigned-shift">
              <div class="shift-row">
                <div class="shift-details">
                  <div class="show-name">${shift.show_name}</div>
                  <div class="shift-date">${AdelaideTime.formatDateAdelaide(shift.date)}</div>
                  <div class="shift-role">${shift.role}</div>
                  <div class="shift-time">${formatShiftTime(shift.arrive_time, shift.depart_time)}</div>
                </div>
                <button class="btn btn-danger" onclick="removeShift(${shift.id})">Remove</button>
              </div>
            </div>
          `).join('');
        }
      }
    }    function populateAvailableShifts() {
      const now = AdelaideTime.getNowAdelaide();
      
      // Filter out shows/performances with shifts that have ended
      const futureShifts = availableShifts.map(show => {
        // Handle flattened structure (shifts directly in show)
        if (show.show_date && show.arrive_time) {
          const shiftEndTime = new Date(show.depart_time);
          if (shiftEndTime > now) {
            return show; // Keep this show as-is
          } else {
            return null; // Filter out this show
          }
        }
        // Handle nested structure (performances with shifts)
        else if (show.performances && Array.isArray(show.performances)) {
          return {
            ...show,
            performances: show.performances.map(performance => ({
              ...performance,
              shifts: performance.shifts.filter(shift => {
                const shiftEndTime = new Date(shift.depart_time);
                return shiftEndTime > now;
              })
            })).filter(performance => performance.shifts.length > 0) // Remove performances with no future shifts
          };
        }
        return null;
      }).filter(show => {
        if (!show) return false;
        // For flattened structure, we already filtered above
        if (show.show_date) return true;
        // For nested structure, check if there are any performances left
        return show.performances && show.performances.length > 0;
      });
      
      if (futureShifts.length === 0) {
        availableContainer.innerHTML = '<div class="no-shifts">No upcoming shifts are currently available for signup.</div>';
        submitBtn.disabled = true;
      } else {
        availableContainer.innerHTML = futureShifts.map(show => {
          // Handle flattened structure
          if (show.show_date && show.arrive_time) {
            return `
              <div style="margin-bottom: 30px;">
                <h3 style="color: #007bff; margin-bottom: 15px; border-bottom: 1px solid #dee2e6; padding-bottom: 5px;">${show.show_name}</h3>
                <div style="margin-bottom: 20px; padding-left: 20px;">
                  <h4 style="color: #666; margin-bottom: 10px; font-size: 1rem;">
                    ${AdelaideTime.formatDateAdelaide(show.show_date)}
                  </h4>
                  <div class="shift">
                    <label style="display: flex; align-items: flex-start; cursor: pointer;">
                      <input type='checkbox' value='${show.id}' data-performance-key="${show.show_date}T${show.start_time}" data-show-name="${show.show_name}" data-performance-date="${show.show_date}" data-performance-start="${show.start_time}" data-performance-end="${show.end_time}" data-shift-role="${show.role}" onchange="handleShiftSelection(this)">
                      <div class="shift-info">
                        <div class="shift-role">${show.role}</div>
                        <div class="shift-time">${formatShiftTime(show.arrive_time, show.depart_time)}</div>
                      </div>
                    </label>
                  </div>
                </div>
              </div>
            `;
          }
          // Handle nested structure
          else {
            return `
              <div style="margin-bottom: 30px;">
                <h3 style="color: #007bff; margin-bottom: 15px; border-bottom: 1px solid #dee2e6; padding-bottom: 5px;">${show.show_name}</h3>
                ${show.performances.map(performance => `
                  <div style="margin-bottom: 20px; padding-left: 20px;">
                    <h4 style="color: #666; margin-bottom: 10px; font-size: 1rem;">
                      ${AdelaideTime.formatDateAdelaide(performance.date)}
                    </h4>
                    ${performance.shifts.map(shift => `
                      <div class="shift">
                        <label style="display: flex; align-items: flex-start; cursor: pointer;">
                          <input type='checkbox' value='${shift.id}' data-performance-key="${performance.date}T${performance.start_time}" data-show-name="${show.show_name}" data-performance-date="${performance.date}" data-performance-start="${performance.start_time}" data-performance-end="${performance.end_time}" data-shift-role="${shift.role}" onchange="handleShiftSelection(this)">
                          <div class="shift-info">
                            <div class="shift-role">${shift.role}</div>
                            <div class="shift-time">${formatShiftTime(shift.arrive_time, shift.depart_time)}</div>
                          </div>
                        </label>
                      </div>
                    `).join('')}
                  </div>
                `).join('')}
              </div>
            `;
          }
        }).join('');
      }
    }
    
    // Track selected shifts by performance to enforce one per performance rule
    const selectedShiftsByPerformance = new Map();

    function handleShiftSelection(checkbox) {
      const performanceKey = checkbox.dataset.performanceKey;
      const shiftId = checkbox.value;
      const shiftRole = checkbox.dataset.shiftRole;
      const showName = checkbox.dataset.showName;
      const performanceDate = checkbox.dataset.performanceDate;
      const performanceStart = checkbox.dataset.performanceStart;
      const performanceEnd = checkbox.dataset.performanceEnd;

      if (checkbox.checked) {
        // Check if this performance already has a selected shift
        if (selectedShiftsByPerformance.has(performanceKey)) {
          const existingShiftId = selectedShiftsByPerformance.get(performanceKey);
          const existingCheckbox = document.querySelector(`input[value="${existingShiftId}"]`);
          
          if (existingCheckbox && existingShiftId !== shiftId) {
            // Uncheck the new selection first
            checkbox.checked = false;
            
            // Show swap confirmation modal
            const existingShiftRole = existingCheckbox.dataset.shiftRole;
            
            Modal.showModal('shift-swap-confirm', {
              title: 'Swap Shifts?',
              body: `
                <p>You're already signed up for a shift in this performance:</p>
                <div class="shift-details-modal">
                  <div class="show-info">${showName}</div>
                  <div class="shift-role">Current: ${existingShiftRole}</div>
                  <div class="shift-time">${new Date(performanceDate).toLocaleDateString()}</div>
                </div>
                <p>Would you like to swap to:</p>
                <div class="shift-details-modal">
                  <div class="shift-role">New: ${shiftRole}</div>
                </div>
              `,
              buttons: [
                {
                  text: 'Cancel',
                  className: 'modal-btn-outline',
                  action: 'cancel'
                },
                {
                  text: 'Swap Shifts',
                  className: 'modal-btn-primary',
                  action: 'swap',
                  handler: () => {
                    // Uncheck the existing shift
                    existingCheckbox.checked = false;
                    selectedShiftsByPerformance.delete(performanceKey);
                    
                    // Check the new shift
                    checkbox.checked = true;
                    selectedShiftsByPerformance.set(performanceKey, shiftId);
                    
                    Modal.closeModal('shift-swap-confirm');
                  }
                }
              ]
            });
            return;
          }
        }
        
        // Add to selected shifts
        selectedShiftsByPerformance.set(performanceKey, shiftId);
      } else {
        // Remove from selected shifts
        selectedShiftsByPerformance.delete(performanceKey);
      }
    }

    async function removeShift(shiftId) {
      Modal.confirm(
        'Remove Shift',
        'Are you sure you want to remove yourself from this shift?',
        async () => {
          try {
            const response = await fetch(`/volunteer/signup/${volunteer.id}/shift`, {
              method: 'DELETE',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({shiftId: shiftId})
            });
            
            if (response.ok) {
              showMessage('success', 'You have been removed from the shift.');
              // Refresh the page to update the lists
              setTimeout(() => location.reload(), 1000);
            } else {
              throw new Error('Failed to remove from shift');
            }
          } catch (error) {
            Modal.error('Error', 'Failed to remove from shift. Please try again.');
          }
        }
      );
    }

    function logout() {
      // Simple redirect to the main route
      window.location.href = '/';
    }

    async function downloadPDF() {
      const pdfButton = document.querySelector('.pdf-button');
      const originalText = pdfButton.innerHTML;
      
      try {
        // Show loading state
        pdfButton.disabled = true;
        pdfButton.innerHTML = '<span>⏳ Generating...</span>';
        
        // Wait for jsPDF to be available
        let attempts = 0;
        while (!window.jspdf && attempts < 50) {
          console.log('Waiting for jsPDF to load...');
          await new Promise(resolve => setTimeout(resolve, 100));
          attempts++;
        }
        
        const response = await fetch(`/volunteer/signup/${volunteer.id}/pdf`);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
          const data = await response.json();
        console.log('PDF data received:', data);
        
        // Check if jsPDF is available
        if (!window.jspdf) {
          throw new Error('jsPDF library not loaded after waiting');
        }
        
        const { jsPDF } = window.jspdf;
        
        if (!jsPDF) {
          throw new Error('jsPDF constructor not available');
        }
          const doc = new jsPDF({
          orientation: 'portrait',
          unit: 'mm',
          format: 'a4'
        });
        
        // A4 dimensions: 210mm x 297mm
        // Use smaller margins: 10mm on all sides
        const pageWidth = 210;
        const pageHeight = 297;
        const margin = 10;
        const contentWidth = pageWidth - (2 * margin);
        const maxY = pageHeight - margin;
        
        // Check if AdelaideTime utilities are available
        if (!window.AdelaideTime) {
          throw new Error('AdelaideTime utilities not loaded');
        }
        
        let yPos = margin + 10;
        
        // Title
        doc.setFontSize(20);
        const volunteerName = data.volunteer?.name || 'Unknown';
        doc.text(`Theatre Shifts for ${volunteerName}`, margin, yPos);
        yPos += 10;
               
        // Generation timestamp
        doc.setFontSize(10);
        const generatedDateStr = AdelaideTime.getCurrentDateAdelaide();
        const generatedTimeStr = AdelaideTime.getCurrentTimeAdelaide();
        doc.text(`Generated: ${generatedDateStr} ${generatedTimeStr}`, margin, yPos);
        yPos += 6;
          // Note about updating
        doc.setFontSize(10);
        doc.text('Note: Login to the website for the most up-to-date information at:', margin, yPos);
        yPos += 5;
        doc.text(window.location.origin, margin, yPos);
        yPos += 15;        // Group shifts by date - add validation
        const shiftsByDate = {};
        const assignedShifts = data.assignedShifts || [];
        assignedShifts.forEach(shift => {
          if (shift && shift.show_date) {
            // Extract date from show_date (which includes time)
            const date = shift.show_date.split('T')[0]; // Get YYYY-MM-DD part
            if (!shiftsByDate[date]) {
              shiftsByDate[date] = [];
            }
            shiftsByDate[date].push(shift);
          }
        });
        
        // Assigned Shifts Details table (on first page)
        doc.setFontSize(16);
        doc.text('Assigned Shifts Details', margin, yPos);
        yPos += 10;
        
        if (assignedShifts.length === 0) {
          doc.setFontSize(10);
          doc.text('No shifts assigned.', margin, yPos);
          yPos += 10;
        } else {
          // Table headers
          doc.setFontSize(10);
          doc.setFont(undefined, 'bold');
          const colWidths = [30, 60, 40, 30, 30]; // Date, Show, Role, Arrive, Depart
          const headers = ['Date', 'Show Name', 'Role', 'Arrive Time', 'Depart Time'];
          let xPos = margin;
          
          // Draw header row
          headers.forEach((header, i) => {
            doc.text(header, xPos, yPos);
            xPos += colWidths[i];
          });
          yPos += 8;
          
          // Draw header underline
          doc.line(margin, yPos - 2, margin + contentWidth, yPos - 2);
          yPos += 5;          // Sort shifts by date, then by arrive time
          const sortedDates = Object.keys(shiftsByDate).sort();
          const allShiftsForTable = [];
          
          sortedDates.forEach(date => {
            const shiftsOnDate = shiftsByDate[date];
            shiftsOnDate.forEach(shift => {
              allShiftsForTable.push(shift);
            });
          });
          
          // Sort all shifts by date, then by arrive time
          allShiftsForTable.sort((a, b) => {
            const dateCompare = new Date(a.show_date) - new Date(b.show_date);
            if (dateCompare !== 0) return dateCompare;
            return new Date(a.arrive_time) - new Date(b.arrive_time);
          });
          
          doc.setFont(undefined, 'normal');
          
          allShiftsForTable.forEach(shift => {
            // Check if we need a new page
            if (yPos > maxY - 15) {
              doc.addPage();
              yPos = margin + 10;
              
              // Redraw headers on new page
              doc.setFont(undefined, 'bold');
              xPos = margin;
              headers.forEach((header, i) => {
                doc.text(header, xPos, yPos);
                xPos += colWidths[i];
              });
              yPos += 8;
              doc.line(margin, yPos - 2, margin + contentWidth, yPos - 2);
              yPos += 5;
              doc.setFont(undefined, 'normal');
            }
            
            xPos = margin;
            const formattedDate = AdelaideTime.formatDateAdelaide(shift.show_date);
            const showName = (shift.show_name || 'Unknown Show').substring(0, 25); // Truncate if too long
            const role = (shift.role || '').substring(0, 15);
            const arriveTime = AdelaideTime.formatTimeAdelaide(shift.arrive_time);
            const departTime = AdelaideTime.formatTimeAdelaide(shift.depart_time);
            
            const rowData = [formattedDate, showName, role, arriveTime, departTime];
            
            rowData.forEach((data, i) => {
              doc.text(data, xPos, yPos);
              xPos += colWidths[i];
            });
            
            yPos += 7;
          });
        }
        // Start calendars on new page
        doc.addPage();
        yPos = margin;
        
        // Calendar section
/*         doc.setFontSize(16);
        doc.text('Shift Calendar Summary', margin, yPos);
        yPos += 15; */
        
        if (Object.keys(shiftsByDate).length === 0) {
          /* doc.setFontSize(10);
          doc.text('No shifts assigned.', margin, yPos);
          yPos += 10; */
        } else {
          // Get unique months with shifts
          const monthsWithShifts = new Set();
          Object.keys(shiftsByDate).forEach(dateStr => {
            const date = new Date(dateStr);
            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            monthsWithShifts.add(monthKey);
          });
          
          const sortedMonths = Array.from(monthsWithShifts).sort();
          let calendarsOnPage = 0;
          const maxCalendarsPerPage = 2;
          
          sortedMonths.forEach((monthKey, index) => {
            const [year, month] = monthKey.split('-').map(Number);
            const monthDate = new Date(year, month - 1, 1);
            
            // Check if we need a new page (2 calendars per page)
            if (calendarsOnPage >= maxCalendarsPerPage) {
              doc.addPage();
              yPos = margin;
              calendarsOnPage = 0;
            }
            
            // Draw calendar for this month
            const calendarWidth = contentWidth;
            const cellWidth = calendarWidth / 7;
            const cellHeight = 20;
            const calendarStartX = margin;
            const calendarStartY = yPos;
            
            // Month and year title
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            const monthName = monthDate.toLocaleDateString('en-AU', { month: 'long', year: 'numeric' });
            doc.text(monthName, margin, yPos);
            yPos += 6;
              // Day headers
            const dayHeaders = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            doc.setFontSize(9);
            doc.setFont(undefined, 'bold');
            for (let i = 0; i < 7; i++) {
              const x = calendarStartX + (i * cellWidth);
              doc.text(dayHeaders[i].substring(0, 3), x + 2, yPos);
            }
            yPos += 3;
            
            // Draw calendar grid
            const firstDay = new Date(year, month - 1, 1);
            const lastDay = new Date(year, month, 0);
            const daysInMonth = lastDay.getDate();
            const firstDayOfWeek = firstDay.getDay(); // 0 = Sunday, 1 = Monday, etc.
            // Adjust for Monday start: Sunday becomes 6, Monday becomes 0, etc.
            const adjustedFirstDay = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
            
            let dayCount = 1;
            let row = 0;
            const maxRows = 6;
              while (dayCount <= daysInMonth && row < maxRows) {
              for (let col = 0; col < 7; col++) {
                const x = calendarStartX + (col * cellWidth);
                const y = yPos + (row * cellHeight);
                
                if (row === 0 && col < adjustedFirstDay) {
                  // Empty cell before month starts - draw border only
                  doc.rect(x, y, cellWidth, cellHeight);
                  continue;
                }
                
                if (dayCount > daysInMonth) {
                  // Empty cell after month ends - draw border only
                  doc.rect(x, y, cellWidth, cellHeight);
                  continue;
                }
                
                // Draw cell border
                doc.rect(x, y, cellWidth, cellHeight);
                
                // Add day number
                doc.setFontSize(10);
                doc.setFont(undefined, 'bold');
                doc.text(dayCount.toString(), x + 2, y + 8);                // Check if this date has shifts
                const dateStr = `${year}-${String(month).padStart(2, '0')}-${String(dayCount).padStart(2, '0')}`;
                if (shiftsByDate[dateStr]) {
                  const shiftsOnDate = shiftsByDate[dateStr];
                  // Sort shifts by arrive time for consistent display
                  shiftsOnDate.sort((a, b) => new Date(a.arrive_time) - new Date(b.arrive_time));
                  
                  doc.setFontSize(7);
                  doc.setFont(undefined, 'normal');
                  let timeY = y + 12;
                  
                  shiftsOnDate.forEach((shift, shiftIndex) => {
                    if (shiftIndex < 3 && timeY < y + cellHeight - 2) { // Max 3 shifts per day
                      const arriveTime = AdelaideTime.formatTimeAdelaide(shift.arrive_time).substring(0, 5);
                      const departTime = AdelaideTime.formatTimeAdelaide(shift.depart_time).substring(0, 5);
                      doc.text(`${arriveTime}-${departTime}`, x + 1, timeY);
                      timeY += 4;
                    }
                  });
                  
                  if (shiftsOnDate.length > 3) {
                    doc.text(`+${shiftsOnDate.length - 3}`, x + 1, timeY);
                  }
                }
                
                dayCount++;
              }
              row++;
            }
            
            yPos += (row * cellHeight) + 10;
            calendarsOnPage++;
          });        }
        
        // Add final note at bottom
        yPos = margin - 3;
        doc.setFontSize(9);
        const websiteUrl = window.location.origin;
        const infoText = `Login to the website for the most up-to-date information: ${websiteUrl}`;
        const infoTextWidth = doc.getTextWidth(infoText);
        doc.text(infoText, 210 - 10 - infoTextWidth, yPos); // Right aligned at 10mm from right edge

        //Generated date/time (in adelaide timezone)
        yPos = margin;
        doc.setFontSize(9);
        const generatedText = `Generated: ${AdelaideTime.getCurrentDateAdelaide()} ${AdelaideTime.getCurrentTimeAdelaide()}`;
        const textWidth = doc.getTextWidth(generatedText);
        doc.text(generatedText, 210 - 10 - textWidth, yPos); // 210 = A4 width, 10 = right margin

        // Save the PDF
        const pdfVolunteerName = data.volunteer?.name || 'volunteer';
        const safeFileName = pdfVolunteerName.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_');
        const currentDate = AdelaideTime.getCurrentDateAdelaide();
        const fileName = `${safeFileName}_shifts_${currentDate}.pdf`;
        doc.save(fileName);
        
        // Success - show completion message briefly
        pdfButton.innerHTML = '<span>✓ Downloaded!</span>';
        setTimeout(() => {
          pdfButton.disabled = false;
          pdfButton.innerHTML = originalText;
        }, 2000);
          } catch (error) {
        console.error('PDF generation failed:', error);
        let errorMessage = 'Failed to generate PDF. Please try again.';
        
        if (error.message.includes('jsPDF')) {
          errorMessage = 'PDF library not loaded. Please refresh the page and try again.';
        } else if (error.message.includes('HTTP error')) {
          errorMessage = 'Server error when fetching data. Please try again.';
        } else if (error.message.includes('AdelaideTime')) {
          errorMessage = 'Timezone utility error. Please refresh the page and try again.';
        }
        
        // Restore button state
        pdfButton.disabled = false;
        pdfButton.innerHTML = originalText;
        
        Modal.error('Error', errorMessage);
      }
    }
    
    function showMessage(type, text) {
      const successMsg = document.getElementById('successMessage');
      const errorMsg = document.getElementById('errorMessage');
      
      if (type === 'success') {
        successMsg.innerHTML = `<strong>Success!</strong> ${text}`;
        successMsg.style.display = 'block';
        errorMsg.style.display = 'none';
      } else {
        errorMsg.innerHTML = `<strong>Error!</strong> ${text}`;
        errorMsg.style.display = 'block';
        successMsg.style.display = 'none';
      }
      
      setTimeout(() => {
        successMsg.style.display = 'none';
        errorMsg.style.display = 'none';
      }, 5000);
    }    // Initialize the page
    window.addEventListener('load', () => {
      console.log('Page loaded. Checking libraries...');
      console.log('jsPDF available:', !!window.jspdf);
      console.log('AdelaideTime available:', !!window.AdelaideTime);
      console.log('Modal available:', !!window.Modal);
      
      // Show warning if jsPDF isn't loaded
      if (!window.jspdf) {
        console.warn('jsPDF not loaded immediately, PDF button may need to wait for library');
      }
      
      generateCalendar();
      populateAssignedShifts();
      populateAvailableShifts();
    });
    
    // Handle form submission for new shifts
    document.getElementById('signupForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const selectedShifts = Array.from(document.querySelectorAll('#availableShifts input[type=checkbox]:checked'));
      
      if (selectedShifts.length === 0) {
        Modal.alert('No Shifts Selected', 'Please select at least one shift to sign up for.');
        return;
      }
      
      const originalText = submitBtn.textContent;
      submitBtn.disabled = true;
      submitBtn.textContent = 'Signing up...';
      
      try {
        const shiftIds = selectedShifts.map(cb => cb.value);
        const response = await fetch(window.location.href, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({shiftIds: shiftIds})
        });
        
        if (response.ok) {
          Modal.success('Success', 'You have successfully signed up for the selected shifts.', () => {
            location.reload();
          });
        } else if (response.status === 409) {
          // Handle conflict - already assigned to a shift for this performance
          const conflictData = await response.json();
          
          if (conflictData.conflictType === 'performance_conflict') {
            const { existingShift, performance, requestedShiftId } = conflictData;
            const requestedCheckbox = document.querySelector(`input[value="${requestedShiftId}"]`);
            const requestedRole = requestedCheckbox ? requestedCheckbox.dataset.shiftRole : 'Unknown Role';
            
            Modal.showModal('conflict-resolution', {
              title: 'Shift Conflict',
              body: `
                <p>You're already assigned to a shift for this performance:</p>
                <div class="shift-details-modal">
                  <div class="show-info">${performance.show_name}</div>
                  <div class="shift-role">Current: ${existingShift.role}</div>
                  <div class="shift-time">${new Date(performance.date).toLocaleDateString()}</div>
                </div>
                <p>Would you like to swap to:</p>
                <div class="shift-details-modal">
                  <div class="shift-role">New: ${requestedRole}</div>
                </div>
              `,
              buttons: [
                {
                  text: 'Keep Current',
                  className: 'modal-btn-outline',
                  action: 'keep'
                },
                {
                  text: 'Swap Shifts',
                  className: 'modal-btn-primary',
                  action: 'swap',
                  handler: async () => {
                    try {
                      const swapResponse = await fetch(`/volunteer/signup/${volunteer.id}/swap`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                          oldShiftId: existingShift.id,
                          newShiftId: requestedShiftId
                        })
                      });
                      
                      if (swapResponse.ok) {
                        Modal.success('Success', 'Shift swapped successfully!', () => {
                          location.reload();
                        });
                      } else {
                        Modal.error('Error', 'Failed to swap shifts. Please try again.');
                      }
                    } catch (error) {
                      Modal.error('Error', 'Failed to swap shifts. Please try again.');
                    }
                    Modal.closeModal('conflict-resolution');
                  }
                }
              ]
            });
          }
        } else {
          throw new Error('Signup failed');
        }
      } catch (error) {
        Modal.error('Error', 'Failed to sign up for shifts. Please try again.');
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
      }
    });
  </script>
</body>
</html>
